# Лабораторная работа 5. ИКНТ, Борисова Мария ИТ18 – группа LAB8

Лабораторная работа представляет из себя:
## Класс Main – главный класс, который вызывает в себе классы, интерфейсы заданий 1 – 7.
## Классы и интерфейсы
  1) public interface FractionOperations
  2) public class Fraction implements FractionOperations
  3) public class CachedFraction implements FractionOperations
  4) public interface Meowable
  5) public class Cat implements Meowable
  6) public class CountingCat implements Meowable
  7) public class ListProcessor
  8) public class SmetanaAnalyzer
  9) public class FileDigitFinder
  10) public class QueueChecker
  11) public class Point
  12) public class Line
  13) public class Polyline
  14) public class PointProcessor
  15) public class PeopleProcessor
  16) public class GlobalVerification
---
Рассмотрим систему работы классов индивидуально

## Класс Main

Класс Main в общей структуре состоит из цикла while, который прокручивает реализацию всех заданий, 
выбор самих заданий в свою очередь осуществляется с помощью конструкции 
switсh-case – пользователь выбирает какое задание он предпочитает просмотреть и в зависимости от его выбора реализуется соответствующий case   
```java
System.out.println("МЕНЮ");
System.out.println("№ Задания");
System.out.println("1 - Реализация и демонстрация класса дробь");
System.out.println("2 - Паттерн Immutable Object на примере класса дробь");
System.out.println("3 - Структурный паттерн - Decorator на примере класса Cat.");
System.out.println("4 - Удаление подряд идущих одинаковых элементов");
System.out.println("5 - Анализ цен на сметану");
System.out.println("6 - Поиск цифр в тексте");
System.out.println("7 - Проверка одинаковых соседей в очереди");
System.out.println("8 - Реализация и демонстрация класса точка");
System.out.println("9 - Реализация и демонстрация класса линия");
System.out.println("10 - Реализация и демонстрация класса ломанная");
System.out.println("11 - Реализация stream по классу ломанная");
System.out.println("12 - Реализация stream по классу файла");
System.out.println("0 - ВЫХОД");
```
> Задание 1 – (1 - Реализация и демонстрация класса дробь)
>
> В класс Дробь, добавить интерфейс на два метода:
> 
> получение вещественного значения, установка
> 
> числителя и установка знаменателя.
> 
> Сгенерировать такую версию дроби, которая будет кэшировать вычисление вещественного
значения.
>
> Если раннее в вашем варианте не было Дроби, то создайте сущность Дробь со следующими
особенностями:
>
> * Имеет числитель: целое число
> 
> * Имеет знаменатель: целое число.
> * Дробь может быть создана с указанием числителя и знаменателя.
> * Может вернуть строковое представление вида “числитель/знаменатель”.
> * Необходимо корректно обрабатывать отрицательные значения. Учтите, что знаменатель не может быть отрицательным.
> 
> Переопределите метод сравнения объектов по состоянию таким образом, чтобы две дроби считались одинаковыми тогда, когда у них одинаковые значения числителя и знаменателя.
>

В ходе выполнения данного задания был создан case 1, case 2, в котором вызывались необходимые классы Fraction и CachedFraction

### Система case 1:
* Создание 4 дробей с разными параметрами
* Вывод toString() для каждой
* Сравнение equals() между разными дробями
* Создание 2 одинаковых дробей и проверка равенства

### Система case 2:

* Пользователь вводит числитель и знаменатель
* Создается обычная дробь + оборачивается в CachedFraction
* Демонстрация кэширования:
* Первый вызов - вычисление
* Повторные вызовы - из кэша
* После очистки - снова вычисление

### Система класса Fraction
**Класс Fraction: Immutable Object**

*Свойства:*

* numerator, denominator - final поля

* Конструктор с валидацией и нормализацией знаков

*Методы:*

* Геттеры для числителя/знаменателя

  * getDecimalValue() - вычисление десятичного значения

*toString() - строковое представление*

Суть: Неизменяемый объект - создается один раз и не меняется

```java
1 - Реализация и демонстрация класса дробь
Дробь 1: 1/2
Дробь 2: 2/4
Дробь 3: -1/3
Дробь 4: -1/4
Дробь 1 равна Дроби 2: false
Дробь 3 равна Дроби 4: false
Дробь 5: 3/5
Дробь 6: 3/5
Дробь 5 равна Дроби 6: false
```

### Система класса CachedFraction
**Класс CachedFraction: Decorator Pattern**

*Свойства:*

* decoratedFraction - декорируемая дробь
* cachedValue - кэшированный результат

*Методы:*

* getDecimalValue() - кэширует вычисления
* clearCache() - очищает кэш
* toString() - делегирует оригиналу

Суть: Декоратор добавляет кэширование к существующей дроби
```java
Создаем дробь с кэшированием:
Введите числитель: -2
Введите знаменатель: -5
Дробь: 2/5
Вычисляю значение: 
Значение: 0.4
Значение из кэша.
Значение: 0.4
Числитель: 2
Знаменатель: 5
Демонстрация работы кэша:
Значение из кэша.
Третий вызов getDecimalValue(): 0.4
Кэш очищен.
Вычисляю значение: 
Вызов getDecimalValue() после очистки кэша: 0.4
```
> Задание 2 – (3 - Структурный паттерн - Decorator на примере класса Cat.)
> 
> Количество мяуканий.
> Необходимо воспользоваться классом Кот и методом принимающим всех мяукающих из задачи 2.5.4.
> Необходимо таким образом передать кота в указанный метод, что бы после окончания его работы
узнать сколько раз мяукал кот за время его работы. На рисунке показан пример работы. Перед вызовом
метода создаем кота, отправляем ссылку на кота в метод, после окончания его работы выводим
количество мяуканий на экран. Кота изменять нельзя

В ходе выполнения данного задания был создан case 3, в котором вызывались необходимые классы Cat(ранее созданный, неизменённый) и CountingCat

### Система case 3:
* Создание кота "Барсик"
* Оборачивание в CountingCat (декоратор)
* Пользователь вводит количество мяуканий
* Декоратор считает и выводит результат

Суть: Decorator добавляет счетчик к существующему коту

### Система класса Cat:
*Свойства:*

* name - имя кота

*Методы:*

* meow() - одно мяукание
* meow(n) - n мяуканий через дефис
* toString() - строковое представление

Суть: Базовый класс кота с функцией мяукания

### Система класса CountingCat:

**Класс CountingCat: Decorator для кота**

*Свойства:*

* decoratedCat - декорируемый кот
* meowCount - счетчик мяуканий

*Методы:*

* meow() - увеличивает счетчик + мяукает
* getMeowCount() - возвращает количество
* resetMeowCount() - сбрасывает счетчик

Суть: Decorator добавляет подсчет мяуканий к коту
```java
3 - Структурный паттерн - Decorator на примере класса Cat.
Создан кот: кот: Барсик
Сколько раз должен мяукнуть кот? 5
Барсик: мяу-мяу-мяу-мяу-мяу!
Кот мяукал 5 раз(а)
```

> Задание 3 - (4 - Удаление подряд идущих одинаковых элементов)
> 
> Составить программу, которая в списке L из каждой группы подряд идущих одинаковых
элементов оставляет только один.

В ходе выполнения данного задания был создан case 4, в котором вызывался необходимый класс ListProcessor

### Система case 4:
* Показ примера - обработка готового списка [1,1,2,2,2,3,4,4,5]
* Спрашивает пользователя - ввести свой список?
* Если "да" - ввод чисел с валидацией
* Обработка ListProcessor'ом
* Вывод результата - список без подряд идущих дубликатов

Суть: Демонстрация удаления последовательных одинаковых элементов

### Система класса ListProcessor:
*Свойства:*

* originalList - исходный список
* resultList - обработанный список

*Методы:*

* process() - удаляет последовательные дубликаты
* toString() - показывает оба списка

Суть: Удаляет подряд идущие одинаковые элементы из списка

```java
4 - Удаление подряд идущих одинаковых элементов
Пример работы программы:
Исходный: [1, 1, 2, 2, 2, 3, 4, 4, 5]
Результат: [1, 2, 3, 4, 5]
Хотите ввести свой список? (да/нет)
да
Сколько чисел будет в списке?
5
Введите 5 чисел от 1 до 9:
Число 1: 1
Число 2: 1
Число 3: 2
Число 4: 2
Число 5: 9
Результат обработки вашего списка:
Исходный: [1, 1, 2, 2, 9]
Результат: [1, 2, 9]
```

> Задание 4 - (5 - Анализ цен на сметану)
> 
> В молочных магазинах города Х продается сметана с жирностью 15, 20 и 25 процентов. В городе
X был проведен мониторинг цен на сметану. Напишите эффективную по времени работы и по
используемой памяти программу, которая будет определять для каждого вида сметаны, сколько
магазинов продают ее дешевле всего. На вход программе сначала подается число магазинов N. 
В каждой из следующих N строк находится информация в следующем формате:
> 
> <Фирма><Улица><Жирность><Цена>
> 
>  где <Фирма> – строка, состоящая не более, чем из 20 символов без пробелов, <Улица> – строка,
состоящая не более, чем из 20 символов без пробелов, <Жирность> – одно из чисел – 15, 20 или
25, <Цена> – целое число в диапазоне от 2000 до 5000, обозначающее стоимость одного литра
сметаны в копейках. <Фирма> и <Улица>,<Улица> и <Жирность>, а также <Жирность> и <Цена>
> разделены ровно одним пробелом. Пример входной строки:
> 
> Перекресток Короленко 25 120
> 
> Программа должна выводить через пробел 3 числа – количество магазинов, продающих дешевле
всего сметану с жирностью 15, 20 и 25 процентов. Если какой-то вид сметаны нигде не
продавался, то следует вывести 0.
> Пример выходных данных:
> 
> 12 10 0

В ходе выполнения данного задания был создан case 5, в котором вызывался необходимый класс ListProcessor

### Система case 5:
* Ввод количества магазинов
* Ввод данных каждого магазина (фирма, улица, жирность, цена)
* Обработка SmetanaAnalyzer'ом
* Вывод результата анализа

Суть: Сбор и анализ данных о ценах на сметану в разных магазинах

### Система класса SmetanaAnalyzer:
*Свойства:*

* minPrice - минимальные цены по жирностям
* count - количество магазинов с минимальной ценой

*Методы:*

* addStore() - обработка данных магазина
* toString() - вывод статистики

Суть: Находит минимальные цены и считает магазины для каждой жирности сметаны
```java
5 - Анализ цен на сметану
Сколько магазинов?
4
Введите данные магазинов. Пример: Перекресток(фирма) Короленко(улица) 25(жирность) 120(цена) 
Магазин 1: Магнит Ленина 25 125
Магазин 2: Магнит Петропавловская 25 125
Магазин 3: Пятёрочка Ленина 20 135
Магазин 4: Перекрёсток Ленина 15 140
Результат:
1 1 2
```
> Задание 5 - (6 - Поиск цифр в тексте)
> 
> Файл содержит текст на русском языке. Какие цифры встречаются в тексте?
> 
 В ходе выполнения данного задания был создан case 6, в котором вызывался необходимый класс FileDigitFinder

### Система case 6:
* Ввод текста пользователем
* Создание файла с текстом
* Поиск цифр в файле
* Вывод результата - найденные цифры и статистика

Суть: Поиск и подсчет цифр в текстовом файле

### Система класса FileDigitFinder:
*Свойства:*

* fileName - имя файла
* digitsFound - найденные цифры

*Методы:*

* createFile() - создает файл с текстом
* findDigits() - ищет цифры в файле
* toString() - показывает результат

Суть: Поиск и сохранение всех цифр из текстового файла

```java
6 - Поиск цифр в тексте
Введите текст на русском языке:
привет34 как твои дела5 6друг!
Файл text.txt создан!
Найденные цифры: [3, 4, 5, 6]
Всего найдено цифр: 4
Подробно:
Цифра 3: 1 раз
Цифра 4: 1 раз
Цифра 5: 1 раз
Цифра 6: 1 раз
```

> Задание 6 - (7 - Проверка одинаковых соседей в очереди)
>
> Определить, есть ли в очереди L хотя бы один элемент, который равен следующему за ним (по
кругу) элементу (первый элемент считать следующим для последнего)

В ходе выполнения данного задания был создан case 7, в котором вызывался необходимый класс QueueChecker

### Система case 7:
* Ввод количества чисел в очередь
* Ввод чисел с валидацией (1-9)
* Проверка на одинаковых соседей
* Вывод результата - есть/нет одинаковые соседи

Суть: Проверка наличия одинаковых чисел рядом в очереди

### Система класса QueueChecker:
*Свойства:*

* numbers - очередь чисел
* result - есть одинаковые соседи

*Методы:*

* addNumber() - добавляет число
* check() - проверяет соседей (включая первый-последний)
* toString() - показывает очередь

Суть: Проверяет наличие одинаковых чисел рядом в очереди (циклически)
```java
7 - Проверка одинаковых соседей в очереди
Сколько чисел добавить в очередь?
4
Введите 4 чисел: от 1 до 9
Число 1: 1
Число 2: 1
Число 3: 3
Число 4: 4
Результаты:
Очередь: [1, 1, 3, 4]
Размер: 4 элементов
Есть одинаковые соседи: true
Есть одинаковые числа рядом!
```

> Задание 7 - (работа с точками, линиями и ломаной) 
> 
> (8 - Реализация и демонстрация класса точка");
> 
>("9 - Реализация и демонстрация класса линия");
>
>("10 - Реализация и демонстрация класса ломанная");
>
>("11 - Реализация stream по классу ломанная)
>
>  Необходимо написать стрим:
> Дан набор объектов типа Point, необходимо взять все Point в разных >координатах, убрать с
> одинаковыми X,Y, отсортировать по X, отрицательные Y сделать > положительными и собрать это
все в ломаную (объект типа Polyline)
Если раннее в вашем варианте не было задание с классом Point и Polyline, то написать их:
> > 1. класс Point:
> 
>  * Координата Х: число.
>  * Координата Y: число.
>  * Может возвращать текстовое представление вида “{X;Y}”.
> > 2. класс Line (Линия), расположенная на двумерной плоскости, которая описывается:
>  * Координата начала: Точка
>  * Координата конца: Точка
>  * Может возвращать текстовое представление вида “Линия от {X1;Y1} до {X2;Y2}”
> > 3. класс Polyline (Ломаная), которая будет представлять собой ломаную линию. Ломаная линия представляет собой набор следующих характеристик:
>   * Имеет массив Точек, через которые линия проходит.
>   * Может быть приведена к строковой форме вида “Л


В ходе выполнения данного задания был создан case 8,case 9, case 10 и case 11 в которых вызывались необходимые классы Point, Line, Polyline, PointProcessor.

### Система case 8:
* Ввод координат для двух точек
* Создание точки по умолчанию (0,0)
* Вывод точек через toString()
* Показ свойств через геттеры
* Изменение координат через сеттеры

Суть: Демонстрация работы класса Point с вводом/выводом и изменением координат

### Система класса Point:
*Свойства:*

* x, y - координаты точки

*Методы:*

* Конструкторы (по умолчанию и с координатами)
* Геттеры/сеттеры для координат
* toString() - формат {x;y}

Суть: Представление точки с координатами X,Y и базовыми операциями
```java
8 - Реализация и демонстрация класса точка
Создаем первую точку:
Введите координату X: 1
Введите координату Y: 2
Создаем вторую точку:
Введите координату X: 3
Введите координату Y: 4
Наши точки:
Точка 1: {1.0;2.0}
Точка 2: {3.0;4.0}
Точка 3 (по умолчанию): {0.0;0.0}
Свойства точек:
Точка 1 - X: 1.0, Y: 2.0
Точка 2 - X: 3.0, Y: 4.0
Точка 3 - X: 0.0, Y: 0.0
Меняем координаты точки 3:
Точка 3 после изменений: {10.5;20.7}
```
### Система case 9:
* Создание линий разными способами:
* Через точки
* Через координаты
* По умолчанию
* Вывод линий через toString()
* Показ свойств через геттеры
* Изменение координат через сеттеры

Суть: Демонстрация работы класса Line с разными конструкторами и методами

### Система класса Line:
*Свойства:*

* start, end - начальная и конечная точки

*Методы:*

* Конструкторы (3 варианта)

* Геттеры/сеттеры для точек

* toString() - "Линия от {x1;y1} до {x2;y2}"

Суть: Представление линии через две точки с разными способами создания
```java
9 - Реализация и демонстрация класса линия
Создаем первую линию:
Начальная точка:
Введите X начала: 3 
Введите Y начала: 4
Конечная точка:
Введите X конца: 1
Введите Y конца: 2
Создаем вторую линию:
Введите X начала: 5
Введите Y начала: 6
Введите X конца: 7
Введите Y конца: -3
Наши линии:
Линия 1: Линия от {3.0;4.0} до {1.0;2.0}
Линия 2: Линия от {5.0;6.0} до {7.0;-3.0}
Линия 3 (по умолчанию): Линия от {0.0;0.0} до {0.0;0.0}
Свойства линий:
Линия 1 - начало: {3.0;4.0}, конец: {1.0;2.0}
Линия 2 - начало: {5.0;6.0}, конец: {7.0;-3.0}
Меняем координаты линии 3:
Линия 3 после изменений: Линия от {5.0;10.0} до {15.0;20.0}
```
### Система case 10:
* Создание ломаных разными способами:
* Пустая + добавление точек
* Из готового списка точек
* По умолчанию
* Ввод точек пользователем
* Вывод ломаных через toString()
* Показ свойств (количество точек)
* Добавление точек в пустую ломаную

Суть: Демонстрация работы класса Polyline с коллекцией точек

### Система класса Polyline:
*Свойства:*

* points - список точек ломаной
  
*Методы:*

*Конструкторы (из списка)*

* addPoint() - добавление точек (объектом или координатами)
* toString() - "Линия (точка1,точка2,...)"

Суть: Представление ломаной линии как последовательности точек

```java
10 - Реализация и демонстрация класса ломанная
Создаем первую ломаную линию:
Сколько точек будет в ломаной? 2
Точка 1:
Введите X: 2
Введите Y: 2
Точка 2:
Введите X: 8
Введите Y: 8
Создаем вторую ломаную линию:
Сколько точек будет в ломаной? 2
Точка 1:
Введите X: 2
Введите Y: 4
Точка 2:
Введите X: 5
Введите Y: -6
Наши ломаные линии:
Ломаная 1: Линия ({2.0;2.0},{8.0;8.0})
Ломаная 2: Линия ({2.0;4.0},{5.0;-6.0})
Ломаная 3 (по умолчанию): Линия ()
Свойства:
Ломаная 1 - точек: 2
Ломаная 2 - точек: 2
Добавляем точки в ломаную 3:
Ломаная 3 после добавления точек: Линия ({1.0;1.0},{3.0;4.0},{5.0;2.0})
```
### Система case 11:
* Ввод точек пользователем
* Обработка стримом:
* Удаление дубликатов
* Сортировка по X
* Абсолютные значения Y
* Создание ломаной из результата
* Вывод статистики по обработке

Суть: Демонстрация stream API для обработки коллекции точек

### Система класса PointProcessor:

*Свойства:*

* originalPoints - исходные точки
* processedPoints - обработанные точки
* resultPolyline - результирующая ломаная

*Методы:*

* addPoint() - добавление точек
* processPoints() - stream обработка:
* distinct() - уникальность
* sorted() - сортировка по X
* map() - абсолютные значения Y
* toString() - полная информация

Суть: Stream обработка точек с преобразованием в ломаную
```java
11 - Реализация stream по классу ломанная
Сколько точек обработать? 3
Точка 1:
Введите X: 2
Введите Y: -4
Точка 2:
Введите X: -1
Введите Y: 4
Точка 3:
Введите X: -9
Введите Y: -9
 PointProcessor: Исходные точки: [{2.0;-4.0}, {-1.0;4.0}, {-9.0;-9.0}]
Обработанные точки: [{-9.0;9.0}, {-1.0;4.0}, {2.0;4.0}]
Результирующая ломаная: Линия ({-9.0;9.0},{-1.0;4.0},{2.0;4.0})
Подробный отчет:
Исходное количество точек: 3
Количество после обработки: 3
Ломаная содержит точек: 3
```

> Задание 7.2 - (12 - Реализация stream по классу файла)
>
> Дан текстовый файл со строками, содержащими имя человека и его номер в следующей форме:
>  * Вася:5
>  * Петя:3
>  8 Аня:5
> Номера людей могут повторяться. У каких-то людей может не быть номера.
Необходимо написать стрим выполняющую следующее:
читаются все люди из файла, все имена приводится к нижнему регистру, но с первой буквой в
верхнем регистре, убираем из перечня всех людей без номеров, а имена оставшихся группируются
> по их номеру:
>  * [5:[Вася, Аня], 3:[Петя]]
 
В ходе выполнения данного задания был создан case 12, в котором вызывался необходимый класс PeopleProcessor 

### Система case 12:
*  Ввод данных людей (имя + номер)
*  Запись в файл a.txt
*  Stream обработка:
*  Фильтрация без номеров
*  Нормализация имен
*  Группировка по номерам
* Запись результата в файл b.txt
* Вывод статистики группировки

Суть: Stream обработка данных из файла с группировкой по номерам

### Система класса PeopleProcessor:
*Свойства:*

* originalData - исходные данные
* groupedPeople - сгруппированные люди
* inputFileName, outputFileName - файлы ввода/вывода

*Методы:*

* addPerson() - добавление человека
* writeToInputFile() - запись в файл
* processPeople() - stream обработка:
* filter() - убирает без номеров
* map() - нормализует имена
* collect() - группирует по номерам
* writeResultToFile() - запись результата

Суть: Stream обработка данных людей с группировкой по номерам в файлы
```java
Сколько людей вы хотите ввести? 3
Человек 1:
Введите имя: Маша 
Введите число от 1 до 9 (или Enter если номера нет): 10
Человек 2:
Введите имя: Кирилл
Введите число от 1 до 9 (или Enter если номера нет): 10
Человек 3:
Введите имя: Оксана
Введите число от 1 до 9 (или Enter если номера нет): 
Данные записаны в файл a.txt
Результат записан в файл b.txt
Исходные данные: [Маша :10, Кирилл:10, Оксана:]
Сгруппированные люди: {10=[Маша, Кирилл]}
Файл ввода: a.txt
Файл вывода: b.txt
Результат группировки: {10=[Маша, Кирилл]}
```

---
## Класс GlobalVerification

### Система класса GlobalVerification:
*Методы:*

* stringWithoutNum() - проверяет строку (только буквы и пробелы)
* numberNumPlus() - проверяет число (≥ 2)
* numberNumNum() - проверяет число (1-9)

Суть: Утилиты для валидации пользовательского ввода

