Задание №1

Разработайте аннотацию @Invoke, со следующими характеристиками:

• Целью может быть только МЕТОД

• Доступна во время исполнения программы

• Не имеет свойств

Создайте класс, содержащий несколько методов, и проаннотируйте хотя бы один из них
аннотацией @Invoke.
Реализуйте обработчик (через Reflection API), который находит методы, отмеченные
аннотацией @Invoke, и вызывает их автоматически

В ходе выполнения задания была создана аннотация @Invoke, класс TestOne, класс InvokeHandler

класс TestOne:

method1() — помечен аннотацией @Invoke, выводит сообщение «Присутствует Invoke».

method2() — без аннотации, выводит сообщение «НЕ присутствует Invoke».

method3() — также с аннотацией @Invoke, выводит сообщение «Присутствует Invoke».

класс InvokeHandler:

Один метод autInvoke(Object obj)

Принимает объект любого класса.

С помощью рефлексии (Class<?>, Method[]) перебирает все публичные методы объекта.

Проверяет, есть ли у метода аннотация @Invoke.

Если аннотация присутствует — вызывает этот метод (method.invoke(obj)).

Пример выполнения работы:



Задание №2

Разработайте аннотацию @Default, со следующими характеристиками:

• Целью может быть ТИП или ПОЛЕ

• Доступна во время исполнения программы

• Имеет обязательное свойство value типа Class

Проаннотируйте какой-либо класс данной аннотацией, указав тип по умолчанию.
Напишите обработчик, который выводит имя указанного класса по умолчанию.

В ходе выполнения работы была создана аннотация Default, класс DefaultHander, класс TestTwo

класс TestTwo: 

Аннотацию на уровне класса:

@Default(String.class) — задаёт тип String по умолчанию для всего класса.

Три поля с собственными аннотациями @Default:

name — тип по умолчанию Integer.

computer — тип по умолчанию Boolean.

password — тип по умолчанию Double.

класс DefaultHander:

Один метод processClass(Class<?> clazz)

Принимает класс для обработки.

Выводит название класса в консоль.

Проверяет наличие аннотации @Default на уровне класса:

Если аннотация есть — выводит тип по умолчанию, указанный в ней.

Перебирает все поля класса с помощью рефлексии (Field[]).

Для каждого поля проверяет наличие аннотации @Default:

Если аннотация присутствует — выводит имя поля и его тип по умолчанию.

Пример выполнения работы:


Задание №3

Разработайте аннотацию @ToString, со следующими характеристиками:

• Целью может быть ТИП или ПОЛЕ

• Доступна во время исполнения программы

• Имеет необязательное свойство valuec двумя вариантами значений: YES или NO

• Значение свойства по умолчанию: YES

Проаннотируйте класс аннотацией @ToString, а одно из полей – с @ToString(Mode.NO).
Создайте метод, который формирует строковое представление объекта, учитывая только те поля,
где @ToString имеет значение YES.

В ходе выполнения работы была создана аннотация ToString, класс ToStringHander, класс TestThree

класс TestThree:

Аннотацию на уровне класса:

@ToString — по умолчанию включает все поля в строковое представление (Mode.YES).

Четыре поля с индивидуальными настройками аннотации @ToString:

name — явно включается в строку (Mode.YES).

age — исключается из строки (Mode.NO).

password — включается в строку (по умолчанию Mode.YES).

sale — исключается из строки (Mode.NO).

Методы-геттеры:

getName() возвращает значение поля name.

getAge() возвращает значение поля age.

getPassword() возвращает значение поля password.

getSalary() возвращает значение поля sale

класс ToStringHander:

Один метод generateToString(Object obj)

Принимает объект любого класса.

Определяет его тип (Class<?> clazz) и начинает формировать строку вида: ClassName{field=value,...}

Перебирает все поля объекта через рефлексию (Field[]).

Проверяет наличие аннотации @ToString у каждого поля.

Если аннотация присутствует и её значение равно Mode.YES:

Делает поле доступным (field.setAccessible(true)).

Получает значение поля у объекта.

Добавляет пару имя=значение в результирующую строку.

Следит за форматированием (ставит запятые между полями).

Возвращает итоговую строку с выбранными полями.

Пример выполнения работы:


Задание №4

Разработайте аннотацию @Validate, со следующими характеристиками:

• Целью может быть ТИП или АННОТАЦИЯ

• Доступна во время исполнения программы

• Имеет обязательное свойство value, типа Class[]

Проаннотируйте класс аннотацией @Validate, передав список типов для проверки.
Реализуйте обработчик, который выводит, какие классы указаны в аннотации.

В ходе выполнения работы была создана аннотация @Validate, класс ValidateHander, класс TestFour

класс TestFour:

Аннотацию на уровне класса:

@Validate({String.class, Integer.class, Double.class}) — указывает, что для данного класса должны проверяться типы String, Integer и Double.

Сам класс не имеет полей и методов — он служит лишь примером применения аннотации @Validate для задания набора типов, которые подлежат проверке.

класс ValidateHander:

Один метод showClasses(Class<?> clazz)

Принимает класс для проверки.

Проверяет, есть ли у него аннотация @Validate.

Если аннотация присутствует:

Получает список типов (Class<?>[]) из аннотации.

Выводит название проверяемого класса и все указанные типы в консоль.

Если аннотации нет — выводит сообщение «Аннотация @Validate не найдена».

Пример выполнения работы:



Задание №5

Разработайте аннотацию @Two, со следующими характеристиками:

• Целью может быть ТИП

• Доступна во время исполнения программы

• Имеет два обязательных свойства: first типа String и second типа int

Проаннотируйте какой-либо класс аннотацией @Two, передав строковое и числовое значения.
Реализуйте обработчик, который считывает и выводит значения этих свойств

В ходе выполнения работы была создана аннотация @Two, класс TwoHander, класс TestFive

класс TestFive:

Аннотацию на уровне класса:

@Two(one = "World", two = 120) — задаёт два свойства:

one — строковое значение "World".

two — числовое значение 120.

Сам класс не имеет полей и методов — он служит примером применения аннотации @Two с несколькими параметрами.

класс TwoHander:

TwoHandler — это класс‑обработчик аннотаций. Он принимает любой класс и:

проверяет наличие аннотации @Two,

если она присутствует — выводит значения её параметров one() и two(),

если отсутствует — сообщает об этом.

Пример выполнения работы:


Задание №6

Разработайте аннотацию @Cache, со следующими характеристиками:

• Целью может быть ТИП

• Доступна во время исполнения программы

• Имеет необязательное свойство value, типа String[]

• Значение свойства по умолчанию: пустой массив

Проаннотируйте класс аннотацией @Cache, указав несколько кешируемых областей.
Создайте обработчик, который выводит список всех кешируемых областей или сообщение, что
список пуст.

В ходе выполнения работы была создана аннотация @Cache, класс CacheHander, класс TestSix, класс CacheSixTwo

класс TestSix:

Аннотация задаёт три области кеширования:

persons

products

orders

Таким образом, класс иллюстрирует, как можно использовать аннотацию для управления несколькими независимыми кешами в приложении.

класс CacheSixTwo:

В этом случае используется значение по умолчанию — пустой массив, что иллюстрирует базовый вариант работы аннотации без дополнительных настроек.

класс CacheHander:

Он принимает любой класс и:

проверяет наличие аннотации @Cache,

если она есть — выводит список кешируемых областей и их количество,

если аннотации нет — сообщает об этом.

Таким образом, CacheHandler превращает аннотацию @Cache в понятный консольный отчёт, показывая, какие области кеширования заданы и сколько их всего.

Пример выполнения работы:





Помимо аннотаций и их представления в работе выполнены тестирования:

ToStringAnnotationTest:

тестовый класс на JUnit 5, предназначенный для проверки работы аннотации @ToString и обработчика ToStringHandler.

Он включает:

тест наличия аннотации @ToString на классе TestThree;

тест значений аннотаций на отдельных полях (name, age, password, sale);

проверку метода generateToString, который формирует строковое представление объекта с учётом аннотации;

параметризованный тест, позволяющий проверять разные объекты и ожидаемые фрагменты строк.

Таким образом, класс демонстрирует полный цикл тестирования аннотации и её обработчика — от проверки наличия до корректности генерации строкового представления.

Пример пройденного тестирования:

![Alt text](<img width="1234" height="619" alt="image" src="https://github.com/user-attachments/assets/4871c799-5e30-4351-81cd-c231ee0a68d7" />)

CacheAnnotationTest:

тестовый класс на JUnit 5, предназначенный для проверки работы аннотации @Cache и обработчика CacheHandler.

Он включает:

проверку корректного чтения списка кешируемых областей у класса TestSix;

проверку пустого массива у класса CacheSixTwo (отсутствие областей кеширования);

мок‑тест вызова метода processClass у CacheHandler;

проверку наличия нескольких областей кеширования (persons, products, orders).

Таким образом, класс демонстрирует полный набор тестов для аннотации @Cache и её обработчика, включая как реальные проверки, так и использование mock‑объектов.


